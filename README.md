# Docker
**1. What is Docker and Why Use It?**

*   **Virtualization vs. Containerization:**
    *   **Virtual Machines (VMs):** VMs emulate an entire operating system (including the kernel) on top of your host OS.  They're heavy, slow to start, and consume a lot of resources. Think of them as running an entire *computer* within your computer.
    *   **Containers (Docker):** Containers share the host OS kernel. They only package the application and its *dependencies* (libraries, configurations).  This makes them lightweight, fast to start, and resource-efficient. Think of them as running just an *application* in an isolated environment.

*   **Key Benefits of Docker:**
    *   **Consistency:** "It works on my machine!" becomes a thing of the past. Docker ensures your application runs the same way everywhere, regardless of the underlying environment (your laptop, a test server, a production cloud).
    *   **Isolation:** Containers are isolated from each other and the host system. This prevents conflicts between applications and improves security.
    *   **Portability:** You can easily move Docker containers between different machines and cloud providers.
    *   **Scalability:** Docker makes it easy to scale your application up or down by creating or destroying containers.
    *   **Version Control:** Docker images can be versioned, making it easy to roll back to previous versions of your application.
    *   **Reproducibility:** Dockerfiles define the steps to build your application, making the build process reproducible.

**2. Docker Installation**

Before you can use Docker, you need to install it.  The installation process varies depending on your operating system.

*   **Windows:**
    1.  **Docker Desktop for Windows:** Download and install from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).  This is the recommended approach.  It includes Docker Engine, Docker CLI, Docker Compose, and other tools.  It may require WSL 2 (Windows Subsystem for Linux 2).
    2.  Enable virtualization in your BIOS settings.

*   **macOS:**
    1.  **Docker Desktop for Mac:** Download and install from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/). Similar to the Windows version, it provides a complete Docker environment.

*   **Linux (Ubuntu/Debian Example):**
    ```bash
    # Update package lists
    sudo apt-get update

    # Install necessary packages
    sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common

    # Add Docker's official GPG key
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

    # Set up the stable repository
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

    # Update package lists again
    sudo apt-get update

    # Install Docker Engine
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io

    # Add your user to the docker group (optional, but recommended to avoid using sudo with Docker)
    sudo usermod -aG docker $USER

    # Log out and log back in, or run 'newgrp docker' for the group change to take effect
    newgrp docker
    ```
    * **CentOS/RHEL** Installation instructions differ slightly, using `yum` instead of `apt-get`.  Refer to the official Docker documentation for your specific Linux distribution.

* **Verify Installation:** After installation, verify that Docker is working:

    ```bash
    docker --version
    docker run hello-world
    ```
    The `hello-world` command should download a test image and run it, printing a welcome message. This confirms Docker is set up correctly.

**3. Key Docker Concepts**

*   **Image:** A read-only template used to create containers.  Think of it as a snapshot of your application and its environment.  Images are built from *Dockerfiles*.
*   **Container:** A running instance of an image. It's an isolated environment where your application runs. You can start, stop, and delete containers.
*   **Dockerfile:** A text file that contains instructions for building a Docker image. It defines the base image, dependencies, commands to run, and other configuration details.
*   **Registry:** A repository for storing and sharing Docker images. Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) is the default public registry. You can also use private registries.
*   **Volume:** A way to persist data generated by and used by containers. Volumes are stored outside the container's filesystem, so the data survives even if the container is deleted.  They are essential for databases and other stateful applications.
*   **Network:** Docker networks allow containers to communicate with each other and with the outside world.
*   **Docker Compose:** A tool for defining and managing multi-container applications. It uses a YAML file (`docker-compose.yml`) to describe the services, networks, and volumes that make up your application.

**4. Essential Docker Commands (with Examples)**

Let's go through the most important Docker commands, with practical examples.

*   **`docker run` (Create and Start a Container)**

    ```bash
    docker run <image_name>  # Simplest form: runs a container from an image
    docker run -d <image_name>  # Run in detached mode (background)
    docker run -it <image_name> /bin/bash  # Run interactively, and get a shell inside the container
    docker run -p 8080:80 <image_name>  # Map port 8080 on the host to port 80 in the container
    docker run --name my_container <image_name> # Assign a name to the container
    docker run -v /host/path:/container/path <image_name> # Mount a host directory as a volume
    docker run -e MY_VAR=value <image_name> # Set environment variables
    docker run --rm <image_name> # Automatically remove the container when it exits

    # Example: Run an Nginx web server
    docker run -d -p 80:80 --name my_nginx nginx
    ```

*   **`docker ps` (List Containers)**

    ```bash
    docker ps      # List running containers
    docker ps -a   # List all containers (including stopped ones)
    docker ps -q   # Only show container IDs
    ```

*   **`docker stop` (Stop a Container)**

    ```bash
    docker stop <container_id_or_name>

    # Example
    docker stop my_nginx
    ```

*   **`docker start` (Start a Stopped Container)**

    ```bash
    docker start <container_id_or_name>

    # Example
    docker start my_nginx
    ```

*   **`docker rm` (Remove a Container)**

    ```bash
    docker rm <container_id_or_name>  # Remove a stopped container
    docker rm -f <container_id_or_name> # Forcefully remove a running container
    ```

*   **`docker images` (List Images)**

    ```bash
    docker images    # List all images
    docker images -q # List image IDs only
    ```

*   **`docker rmi` (Remove an Image)**

    ```bash
    docker rmi <image_id_or_name>  # Remove an image
    docker rmi -f <image_id_or_name> # Force remove an image (even if used by containers)
    ```
    **Important:** You can't remove an image if it's being used by a running or stopped container.  You must remove the containers first.

*   **`docker build` (Build an Image from a Dockerfile)**

    ```bash
    docker build -t my_image:tag .  # Build from the Dockerfile in the current directory
    docker build -t my_image:1.0 -f path/to/Dockerfile . #Specify Dockerfile path and tag
    ```
    *   `-t`: Specifies the image name and tag (e.g., `my_image:latest`, `my_app:v1.0`).  The tag is optional; if omitted, it defaults to `latest`.
    *   `.`: Specifies the build context (usually the current directory). Docker sends this context to the Docker daemon.

*   **`docker pull` (Pull an Image from a Registry)**

    ```bash
    docker pull <image_name>   # Pull from Docker Hub
    docker pull <registry>/<image_name>:<tag> # Pull from a specific registry

    # Example
    docker pull ubuntu:20.04
    docker pull myregistry.com/my_app:latest
    ```

*   **`docker push` (Push an Image to a Registry)**

    ```bash
    docker push <image_name>  # Push to Docker Hub (requires login)
    docker push <registry>/<image_name>:<tag> # Push to a specific registry

    # Example (after tagging)
    docker tag my_image myusername/my_image:v1
    docker push myusername/my_image:v1
    ```
    *   **Important:** You need to be logged in to the registry (using `docker login`) before pushing.  For Docker Hub, you'll need a Docker Hub account.  For private registries, you'll need credentials.

*   **`docker exec` (Run a Command in a Running Container)**

    ```bash
    docker exec -it <container_id_or_name> /bin/bash  # Get an interactive shell
    docker exec <container_id_or_name> ls -l /  # Run a command (e.g., list files)

    #Example
    docker exec -it my_nginx bash #Get a shell inside the my_nginx container
    ```

*   **`docker logs` (View Container Logs)**

    ```bash
    docker logs <container_id_or_name>  # Show the container's standard output/error
    docker logs -f <container_id_or_name> # Follow the log output (like 'tail -f')
    ```

*   **`docker inspect` (Get Detailed Information about a Container or Image)**

    ```bash
    docker inspect <container_id_or_name_or_image_id_or_name> # Get detailed JSON output
    docker inspect --format='{{.NetworkSettings.IPAddress}}' <container_id> # Get specific information
    ```

*   **`docker network` (Manage Networks)**

    ```bash
    docker network ls            # List networks
    docker network create my_net  # Create a new network
    docker network connect my_net <container_id> # Connect a container to a network
    docker network disconnect my_net <container_id> # Disconnect a container
    ```

* **`docker volume` (Manage Volumes)**

    ```bash
       docker volume ls            # List volumes
       docker volume create my_vol # Create a new volume
       docker volume rm my_vol     # Remove a volume
       docker volume inspect my_vol # Inspect volume
    ```

* **`docker login` (Log in to a Registry)**
  ```bash
  docker login # Login to Docker Hub (prompts for username and password)
  docker login myregistry.com  # Login to a custom registry
  ```

* **`docker logout` (Log out of a Registry)**
  ```bash
    docker logout # Logout from Docker Hub
    docker logout myregistry.com #Logout from custom registry
  ```

* **`docker system prune` (Clean Up Unused Resources)**
  ```bash
  docker system prune -a # Remove all unused images, containers, networks, and volumes (use with caution!)
  docker system prune  # Remove stopped containers and dangling images
  ```

**5. Dockerfile Example**

```dockerfile
# Use an official Python runtime as a parent image
FROM python:3.9-slim-buster

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
```

*   **`FROM`:** Specifies the base image.
*   **`WORKDIR`:** Sets the working directory inside the container.
*   **`COPY`:** Copies files from the host machine to the container.
*   **`RUN`:** Executes commands inside the container (e.g., installing dependencies).
*   **`EXPOSE`:** Informs Docker that the container listens on the specified port(s) at runtime. This doesn't actually *publish* the port; use `-p` with `docker run` to do that.
*   **`ENV`:** Sets environment variables.
*   **`CMD`:** Specifies the command to run when the container starts.  There can only be one `CMD` instruction (or it will be overridden).

**6. Docker Compose Example (`docker-compose.yml`)**

```yaml
version: "3.9"  # Use version 3.9 of the Compose file format

services:
  web:
    build: .  # Build from the Dockerfile in the current directory
    ports:
      - "5000:5000"  # Map host port 5000 to container port 5000
    volumes:
      - .:/code  # Mount the current directory as a volume
    depends_on:
      - db  # This service depends on the 'db' service

  db:
    image: postgres:13  # Use the official PostgreSQL image
    ports:
      - "5432:5432" #Expose Postgres port
    environment:
      POSTGRES_PASSWORD: mysecretpassword  # Set the PostgreSQL password
    volumes:
      - pgdata:/var/lib/postgresql/data #Named volume for persistent data

volumes:
  pgdata: #Define a named volume
```

*   **`version`:** Specifies the version of the Compose file format.
*   **`services`:** Defines the different services that make up your application.
*   **`build`:** Specifies how to build the image for a service (if needed).
*   **`ports`:** Maps ports between the host and the container.
*   **`volumes`:** Defines volumes to persist data.
*   **`depends_on`:** Specifies dependencies between services.
*   **`environment`:** Sets environment variables for a service.
*  **`image`**: Specifies the image to use for the service.

To run this Compose file:

```bash
docker-compose up -d  # Start the services in detached mode
docker-compose down   # Stop and remove the services
```

**7. Best Practices**

*   **Keep Images Small:** Use smaller base images (e.g., `alpine` versions). Minimize the number of layers. Use multi-stage builds.
*   **Use `.dockerignore`:** Create a `.dockerignore` file to exclude unnecessary files and directories from the build context.  This makes builds faster and images smaller.  It works similarly to `.gitignore`.
*   **Use Tags Wisely:** Use specific tags (e.g., `my_app:v1.2.3`) instead of relying on `latest`. This makes deployments more predictable and allows for easy rollbacks.
*   **Use Volumes for Persistent Data:** Don't store data that needs to persist inside the container's filesystem. Use volumes instead.
*   **Secure Your Docker Environment:** Keep Docker updated.  Limit container privileges.  Use a secure registry.
*   **Use a Linter:** Tools like `hadolint` can help you write better Dockerfiles.

This comprehensive guide covers the most important aspects of Docker, from installation and basic concepts to essential commands and best practices.  It includes detailed examples and explanations to help you get started with containerization.  Remember to consult the official Docker documentation ([https://docs.docker.com/](https://docs.docker.com/)) for more in-depth information and advanced topics. This is a large topic, so practice is key. Start with simple examples and gradually work your way up to more complex applications.
Okay, let's break down Docker, covering the fundamentals and providing a practical guide with common commands.  I'll structure this into sections:

**1. What is Docker and Why Use It?**

*   **Virtualization vs. Containerization:**
    *   **Virtual Machines (VMs):** VMs emulate an entire operating system (including the kernel) on top of your host OS.  They're heavy, slow to start, and consume a lot of resources. Think of them as running an entire *computer* within your computer.
    *   **Containers (Docker):** Containers share the host OS kernel. They only package the application and its *dependencies* (libraries, configurations).  This makes them lightweight, fast to start, and resource-efficient. Think of them as running just an *application* in an isolated environment.

*   **Key Benefits of Docker:**
    *   **Consistency:** "It works on my machine!" becomes a thing of the past. Docker ensures your application runs the same way everywhere, regardless of the underlying environment (your laptop, a test server, a production cloud).
    *   **Isolation:** Containers are isolated from each other and the host system. This prevents conflicts between applications and improves security.
    *   **Portability:** You can easily move Docker containers between different machines and cloud providers.
    *   **Scalability:** Docker makes it easy to scale your application up or down by creating or destroying containers.
    *   **Version Control:** Docker images can be versioned, making it easy to roll back to previous versions of your application.
    *   **Reproducibility:** Dockerfiles define the steps to build your application, making the build process reproducible.

**2. Docker Installation**

Before you can use Docker, you need to install it.  The installation process varies depending on your operating system.

*   **Windows:**
    1.  **Docker Desktop for Windows:** Download and install from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).  This is the recommended approach.  It includes Docker Engine, Docker CLI, Docker Compose, and other tools.  It may require WSL 2 (Windows Subsystem for Linux 2).
    2.  Enable virtualization in your BIOS settings.

*   **macOS:**
    1.  **Docker Desktop for Mac:** Download and install from [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/). Similar to the Windows version, it provides a complete Docker environment.

*   **Linux (Ubuntu/Debian Example):**
    ```bash
    # Update package lists
    sudo apt-get update

    # Install necessary packages
    sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common

    # Add Docker's official GPG key
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

    # Set up the stable repository
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

    # Update package lists again
    sudo apt-get update

    # Install Docker Engine
    sudo apt-get install -y docker-ce docker-ce-cli containerd.io

    # Add your user to the docker group (optional, but recommended to avoid using sudo with Docker)
    sudo usermod -aG docker $USER

    # Log out and log back in, or run 'newgrp docker' for the group change to take effect
    newgrp docker
    ```
    * **CentOS/RHEL** Installation instructions differ slightly, using `yum` instead of `apt-get`.  Refer to the official Docker documentation for your specific Linux distribution.

* **Verify Installation:** After installation, verify that Docker is working:

    ```bash
    docker --version
    docker run hello-world
    ```
    The `hello-world` command should download a test image and run it, printing a welcome message. This confirms Docker is set up correctly.

**3. Key Docker Concepts**

*   **Image:** A read-only template used to create containers.  Think of it as a snapshot of your application and its environment.  Images are built from *Dockerfiles*.
*   **Container:** A running instance of an image. It's an isolated environment where your application runs. You can start, stop, and delete containers.
*   **Dockerfile:** A text file that contains instructions for building a Docker image. It defines the base image, dependencies, commands to run, and other configuration details.
*   **Registry:** A repository for storing and sharing Docker images. Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)) is the default public registry. You can also use private registries.
*   **Volume:** A way to persist data generated by and used by containers. Volumes are stored outside the container's filesystem, so the data survives even if the container is deleted.  They are essential for databases and other stateful applications.
*   **Network:** Docker networks allow containers to communicate with each other and with the outside world.
*   **Docker Compose:** A tool for defining and managing multi-container applications. It uses a YAML file (`docker-compose.yml`) to describe the services, networks, and volumes that make up your application.

**4. Essential Docker Commands (with Examples)**

Let's go through the most important Docker commands, with practical examples.

*   **`docker run` (Create and Start a Container)**

    ```bash
    docker run <image_name>  # Simplest form: runs a container from an image
    docker run -d <image_name>  # Run in detached mode (background)
    docker run -it <image_name> /bin/bash  # Run interactively, and get a shell inside the container
    docker run -p 8080:80 <image_name>  # Map port 8080 on the host to port 80 in the container
    docker run --name my_container <image_name> # Assign a name to the container
    docker run -v /host/path:/container/path <image_name> # Mount a host directory as a volume
    docker run -e MY_VAR=value <image_name> # Set environment variables
    docker run --rm <image_name> # Automatically remove the container when it exits

    # Example: Run an Nginx web server
    docker run -d -p 80:80 --name my_nginx nginx
    ```

*   **`docker ps` (List Containers)**

    ```bash
    docker ps      # List running containers
    docker ps -a   # List all containers (including stopped ones)
    docker ps -q   # Only show container IDs
    ```

*   **`docker stop` (Stop a Container)**

    ```bash
    docker stop <container_id_or_name>

    # Example
    docker stop my_nginx
    ```

*   **`docker start` (Start a Stopped Container)**

    ```bash
    docker start <container_id_or_name>

    # Example
    docker start my_nginx
    ```

*   **`docker rm` (Remove a Container)**

    ```bash
    docker rm <container_id_or_name>  # Remove a stopped container
    docker rm -f <container_id_or_name> # Forcefully remove a running container
    ```

*   **`docker images` (List Images)**

    ```bash
    docker images    # List all images
    docker images -q # List image IDs only
    ```

*   **`docker rmi` (Remove an Image)**

    ```bash
    docker rmi <image_id_or_name>  # Remove an image
    docker rmi -f <image_id_or_name> # Force remove an image (even if used by containers)
    ```
    **Important:** You can't remove an image if it's being used by a running or stopped container.  You must remove the containers first.

*   **`docker build` (Build an Image from a Dockerfile)**

    ```bash
    docker build -t my_image:tag .  # Build from the Dockerfile in the current directory
    docker build -t my_image:1.0 -f path/to/Dockerfile . #Specify Dockerfile path and tag
    ```
    *   `-t`: Specifies the image name and tag (e.g., `my_image:latest`, `my_app:v1.0`).  The tag is optional; if omitted, it defaults to `latest`.
    *   `.`: Specifies the build context (usually the current directory). Docker sends this context to the Docker daemon.

*   **`docker pull` (Pull an Image from a Registry)**

    ```bash
    docker pull <image_name>   # Pull from Docker Hub
    docker pull <registry>/<image_name>:<tag> # Pull from a specific registry

    # Example
    docker pull ubuntu:20.04
    docker pull myregistry.com/my_app:latest
    ```

*   **`docker push` (Push an Image to a Registry)**

    ```bash
    docker push <image_name>  # Push to Docker Hub (requires login)
    docker push <registry>/<image_name>:<tag> # Push to a specific registry

    # Example (after tagging)
    docker tag my_image myusername/my_image:v1
    docker push myusername/my_image:v1
    ```
    *   **Important:** You need to be logged in to the registry (using `docker login`) before pushing.  For Docker Hub, you'll need a Docker Hub account.  For private registries, you'll need credentials.

*   **`docker exec` (Run a Command in a Running Container)**

    ```bash
    docker exec -it <container_id_or_name> /bin/bash  # Get an interactive shell
    docker exec <container_id_or_name> ls -l /  # Run a command (e.g., list files)

    #Example
    docker exec -it my_nginx bash #Get a shell inside the my_nginx container
    ```

*   **`docker logs` (View Container Logs)**

    ```bash
    docker logs <container_id_or_name>  # Show the container's standard output/error
    docker logs -f <container_id_or_name> # Follow the log output (like 'tail -f')
    ```

*   **`docker inspect` (Get Detailed Information about a Container or Image)**

    ```bash
    docker inspect <container_id_or_name_or_image_id_or_name> # Get detailed JSON output
    docker inspect --format='{{.NetworkSettings.IPAddress}}' <container_id> # Get specific information
    ```

*   **`docker network` (Manage Networks)**

    ```bash
    docker network ls            # List networks
    docker network create my_net  # Create a new network
    docker network connect my_net <container_id> # Connect a container to a network
    docker network disconnect my_net <container_id> # Disconnect a container
    ```

* **`docker volume` (Manage Volumes)**

    ```bash
       docker volume ls            # List volumes
       docker volume create my_vol # Create a new volume
       docker volume rm my_vol     # Remove a volume
       docker volume inspect my_vol # Inspect volume
    ```

* **`docker login` (Log in to a Registry)**
  ```bash
  docker login # Login to Docker Hub (prompts for username and password)
  docker login myregistry.com  # Login to a custom registry
  ```

* **`docker logout` (Log out of a Registry)**
  ```bash
    docker logout # Logout from Docker Hub
    docker logout myregistry.com #Logout from custom registry
  ```

* **`docker system prune` (Clean Up Unused Resources)**
  ```bash
  docker system prune -a # Remove all unused images, containers, networks, and volumes (use with caution!)
  docker system prune  # Remove stopped containers and dangling images
  ```

**5. Dockerfile Example**

```dockerfile
# Use an official Python runtime as a parent image
FROM python:3.9-slim-buster

# Set the working directory to /app
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 80 available to the world outside this container
EXPOSE 80

# Define environment variable
ENV NAME World

# Run app.py when the container launches
CMD ["python", "app.py"]
```

*   **`FROM`:** Specifies the base image.
*   **`WORKDIR`:** Sets the working directory inside the container.
*   **`COPY`:** Copies files from the host machine to the container.
*   **`RUN`:** Executes commands inside the container (e.g., installing dependencies).
*   **`EXPOSE`:** Informs Docker that the container listens on the specified port(s) at runtime. This doesn't actually *publish* the port; use `-p` with `docker run` to do that.
*   **`ENV`:** Sets environment variables.
*   **`CMD`:** Specifies the command to run when the container starts.  There can only be one `CMD` instruction (or it will be overridden).

**6. Docker Compose Example (`docker-compose.yml`)**

```yaml
version: "3.9"  # Use version 3.9 of the Compose file format

services:
  web:
    build: .  # Build from the Dockerfile in the current directory
    ports:
      - "5000:5000"  # Map host port 5000 to container port 5000
    volumes:
      - .:/code  # Mount the current directory as a volume
    depends_on:
      - db  # This service depends on the 'db' service

  db:
    image: postgres:13  # Use the official PostgreSQL image
    ports:
      - "5432:5432" #Expose Postgres port
    environment:
      POSTGRES_PASSWORD: mysecretpassword  # Set the PostgreSQL password
    volumes:
      - pgdata:/var/lib/postgresql/data #Named volume for persistent data

volumes:
  pgdata: #Define a named volume
```

*   **`version`:** Specifies the version of the Compose file format.
*   **`services`:** Defines the different services that make up your application.
*   **`build`:** Specifies how to build the image for a service (if needed).
*   **`ports`:** Maps ports between the host and the container.
*   **`volumes`:** Defines volumes to persist data.
*   **`depends_on`:** Specifies dependencies between services.
*   **`environment`:** Sets environment variables for a service.
*  **`image`**: Specifies the image to use for the service.

To run this Compose file:

```bash
docker-compose up -d  # Start the services in detached mode
docker-compose down   # Stop and remove the services
```

**7. Best Practices**

*   **Keep Images Small:** Use smaller base images (e.g., `alpine` versions). Minimize the number of layers. Use multi-stage builds.
*   **Use `.dockerignore`:** Create a `.dockerignore` file to exclude unnecessary files and directories from the build context.  This makes builds faster and images smaller.  It works similarly to `.gitignore`.
*   **Use Tags Wisely:** Use specific tags (e.g., `my_app:v1.2.3`) instead of relying on `latest`. This makes deployments more predictable and allows for easy rollbacks.
*   **Use Volumes for Persistent Data:** Don't store data that needs to persist inside the container's filesystem. Use volumes instead.
*   **Secure Your Docker Environment:** Keep Docker updated.  Limit container privileges.  Use a secure registry.
*   **Use a Linter:** Tools like `hadolint` can help you write better Dockerfiles.

This comprehensive guide covers the most important aspects of Docker, from installation and basic concepts to essential commands and best practices.  It includes detailed examples and explanations to help you get started with containerization.  Remember to consult the official Docker documentation ([https://docs.docker.com/](https://docs.docker.com/)) for more in-depth information and advanced topics. This is a large topic, so practice is key. Start with simple examples and gradually work your way up to more complex applications.
